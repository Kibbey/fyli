# Technical Design Document: MVP Core â€” Capture & Share

**PRD Reference:** [PRD_MVP_CORE.md](/docs/prd/PRD_MVP_CORE.md)

---

## Overview

Build a new Vue 3 frontend that implements the MVP core loop (create account â†’ capture memory â†’ share via link â†’ recipient views â†’ recipient signs up). The existing C#/.NET backend is reused entirely, with **one exception**: new endpoints for token-based shareable memory links (the existing `ShareRequest` system handles connection invitations, not anonymous per-memory sharing).

---

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Vue 3 Frontend (NEW)               â”‚
â”‚   Composition API, TypeScript, Pinia, Bootstrap â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ HTTPS / JSON
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           C#/.NET Backend (EXISTING)            â”‚
â”‚                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”   â”‚
â”‚  â”‚ EXISTING: UserController, DropController,â”‚   â”‚
â”‚  â”‚ CommentController, ConnectionController, â”‚   â”‚
â”‚  â”‚ ImageController, MovieController         â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”¤   â”‚
â”‚  â”‚ NEW: ShareLinkController                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”˜   â”‚
â”‚                                                 â”‚
â”‚  Services â†’ Repositories â†’ PostgreSQL           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Phase 1: Backend â€” Shareable Memory Links

This is the **only** backend work in the entire MVP. Everything else is frontend-only.

### 1.1 Data Model

This project uses **EF Core Code-First migrations**. Schema changes are made by:
1. Creating/updating POCO entity classes in `cimplur-core/Memento/Domain/Entities/`
2. Adding FK configuration in `StreamContext.cs` via `OnModelCreating`
3. Adding `DbSet<T>` property to `StreamContext.cs`
4. Running `dotnet ef migrations add <MigrationName>` to generate the migration

**No raw SQL is written for schema changes.** The SQL below is shown for reference only â€” EF Core generates it from the entity and configuration.

New table: `MemoryShareLinks` (generated from entity below)

```sql
-- Reference only â€” generated by EF Core from the POCO entity + StreamContext config
CREATE TABLE MemoryShareLinks (
    MemoryShareLinkId SERIAL PRIMARY KEY,
    DropId INT NOT NULL REFERENCES Drops(DropId),
    CreatorUserId INT NOT NULL REFERENCES UserProfiles(UserId),
    Token UUID NOT NULL DEFAULT gen_random_uuid(),
    IsActive BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedAt TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ExpiresAt TIMESTAMPTZ NULL,
    ViewCount INT NOT NULL DEFAULT 0
);

CREATE UNIQUE INDEX IX_MemoryShareLinks_Token ON MemoryShareLinks(Token);
CREATE INDEX IX_MemoryShareLinks_DropId ON MemoryShareLinks(DropId);
```

**Design decisions:**
- Separate table from `ShareRequests` â€” that system handles user-to-user connection invitations with email matching, group sharing, and bidirectional connection creation. Memory share links are simpler: one token â†’ one memory â†’ anonymous read access.
- `ExpiresAt` nullable â€” links don't expire by default, but the creator can revoke (set `IsActive = false`).
- `ViewCount` for basic analytics.

### 1.2 Entity (POCO)

```
cimplur-core/Memento/Domain/Entities/MemoryShareLink.cs
```

```csharp
public class MemoryShareLink
{
    public int MemoryShareLinkId { get; set; }
    public int DropId { get; set; }
    public int CreatorUserId { get; set; }
    public Guid Token { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? ExpiresAt { get; set; }
    public int ViewCount { get; set; }

    public virtual Drop Drop { get; set; }
    public virtual UserProfile Creator { get; set; }
}
```

Add to `StreamContext.cs`:

```csharp
// DbSet property
public DbSet<MemoryShareLink> MemoryShareLinks { get; set; }
```

Add FK configuration in `OnModelCreating`:

```csharp
// In StreamContext.OnModelCreating(ModelBuilder modelBuilder)
modelBuilder.Entity<MemoryShareLink>(entity =>
{
    entity.HasKey(e => e.MemoryShareLinkId);

    entity.HasIndex(e => e.Token).IsUnique();
    entity.HasIndex(e => e.DropId);

    entity.HasOne(e => e.Drop)
        .WithMany()
        .HasForeignKey(e => e.DropId)
        .OnDelete(DeleteBehavior.Restrict);

    entity.HasOne(e => e.Creator)
        .WithMany()
        .HasForeignKey(e => e.CreatorUserId)
        .OnDelete(DeleteBehavior.Restrict);
});
```

Then generate migration:

```bash
cd cimplur-core/Memento/Domain
dotnet ef migrations add AddMemoryShareLinks
```

### 1.3 Interface & Service

```
cimplur-core/Memento/Domain/Repositories/IMemoryShareLinkService.cs
cimplur-core/Memento/Domain/Repositories/MemoryShareLinkService.cs
```

**Interface:**

```csharp
public interface IMemoryShareLinkService
{
    Task<Guid> CreateLinkAsync(int userId, int dropId);
    Task<SharedMemoryViewModel> GetMemoryByTokenAsync(Guid token);
    Task<string> RegisterAndConnectAsync(Guid token, string email, string name, bool acceptTerms);
    Task DeactivateLinkAsync(int userId, int dropId);
}
```

**Methods:**

| Method | Description |
|--------|-------------|
| `CreateLinkAsync(int userId, int dropId)` | Verify user owns the drop. Create `MemoryShareLink` with new token. Return token. If link already exists and is active, return existing token. |
| `GetMemoryByTokenAsync(Guid token)` | Find active, non-expired link. Increment `ViewCount` via direct SQL (`UPDATE ... SET ViewCount = ViewCount + 1`) to avoid race conditions under concurrent access. Return drop with content, images, movies, comments, and creator name. No auth required. |
| `RegisterAndConnectAsync(Guid token, string email, string name, bool acceptTerms)` | **Delegates to existing services** â€” does NOT reimplement registration. Calls `UserService` for account creation (preserving existing behavior: hello-world content, welcome emails, terms acceptance) and `SharingService` for bidirectional `UserUser` connection creation. Returns JWT via existing `UserWebToken.generateJwtToken`. If user already exists, skips registration and only creates connection. If already connected, skips connection creation. |
| `DeactivateLinkAsync(int userId, int dropId)` | Set `IsActive = false`. Only creator can deactivate. |

**Service delegation pattern:**

```csharp
public class MemoryShareLinkService : IMemoryShareLinkService
{
    private readonly StreamContext _context;
    private readonly IUserService _userService;
    private readonly ISharingService _sharingService;

    // RegisterAndConnectAsync delegates:
    // 1. _userService.Register(email, name, acceptTerms) â€” or find existing
    // 2. _sharingService.CreateConnection(creatorUserId, newUserId) â€” bidirectional
    // 3. UserWebToken.generateJwtToken(newUserId) â€” return JWT
}
```

### 1.4 Controller

```
cimplur-core/Memento/Memento/Controllers/ShareLinkController.cs
```

| Endpoint | Auth | Description |
|----------|------|-------------|
| `POST /api/sharelinks/{dropId}` | Required | Generate shareable link. Returns `{ token, url }` |
| `GET /api/sharelinks/{token}` | None | Get memory data for public view. Returns drop + content + images + movies + comments + creator name |
| `POST /api/sharelinks/{token}/register` | None | Light registration: `{ email, name, acceptTerms }`. Delegates to UserService + SharingService. Returns JWT |
| `DELETE /api/sharelinks/{dropId}` | Required | Deactivate link |
| `POST /api/sharelinks/{token}/signin` | None | Existing user sign-in: `{ email }`. Triggers magic link. |
| `POST /api/sharelinks/{token}/claim` | Required | Authenticated user claims permanent drop access |

### 1.5 Public View Response Model

```csharp
public class SharedMemoryViewModel
{
    public int DropId { get; set; }              // Needed for POST /api/comments after registration
    public string CreatorName { get; set; }
    public DateTime Date { get; set; }
    public string Content { get; set; }          // From ContentDrop.Stuff
    public List<ImageViewModel> Images { get; set; }
    public List<MovieViewModel> Movies { get; set; }
    public List<CommentViewModel> Comments { get; set; }
}
```

### 1.6 Rate Limiting & Security

Unauthenticated endpoints require rate limiting to prevent abuse:

| Endpoint | Limit | Rationale |
|----------|-------|-----------|
| `GET /api/sharelinks/{token}` | 60 req/min per IP | Prevent token enumeration |
| `POST /api/sharelinks/{token}/register` | 5 req/min per IP | Prevent spam account creation |

Implementation: Use ASP.NET rate limiting middleware (`Microsoft.AspNetCore.RateLimiting`). Apply via `[EnableRateLimiting("policy")]` attribute on controller methods.

**Token security:** UUIDs (v4) have 122 bits of randomness â€” enumeration is not practically feasible, but rate limiting provides defense in depth.

### 1.7 Sharing Private Memories

A user **can** generate a share link for a memory marked as "private." The link grants read-only access to anyone with the token regardless of privacy setting. Privacy controls who sees the memory in the authenticated stream; share links are an explicit act of sharing that overrides stream visibility. This is intentional â€” a parent may want a memory private from their connection feed but still shareable via a direct link.

### 1.8 Permanent Drop Access via Share Link

When a user interacts with a share link while authenticated (or becomes authenticated through it), they receive **permanent access** to the shared drop. This means the drop appears in their normal stream via the existing `GetAllDrops` query â€” no token needed for subsequent views.

**Three scenarios:**

| Scenario | Trigger | What Happens |
|----------|---------|--------------|
| **Anonymous registers** | `POST /api/sharelinks/{token}/register` | New account created, connection + tag sharing established, drop visible in stream |
| **Existing user signs in** | `POST /api/sharelinks/{token}/signin` | JWT returned, connection + tag sharing established if not already present |
| **Already authenticated user views link** | `GET /api/sharelinks/{token}` with valid JWT | Connection + tag sharing established if not already present |

#### How It Works

The existing access model: a user sees a drop if they're a `TagViewer` on any of the drop's tags. To grant permanent access, the share link flow must:

1. **Create bidirectional `UserUser` connection** between the drop creator and the viewer (if not already connected)
2. **Add viewer as `TagViewer`** on the drop's tags (so `GetAllDrops` includes this drop)
3. **Call `PopulateEveryone`** for both users (keeps "All Connections" tag in sync)

#### Implementation: `GrantDropAccessAsync` method on `MemoryShareLinkService`

```csharp
/// <summary>
/// Grants permanent access to the shared drop by creating a connection
/// and adding the user as a TagViewer on the drop's tags.
/// Idempotent â€” safe to call multiple times for the same user/drop.
/// </summary>
private async Task GrantDropAccessAsync(int viewerUserId, MemoryShareLink shareLink)
{
    int creatorUserId = shareLink.CreatorUserId;
    int dropId = shareLink.DropId;

    // Skip if viewer is the creator
    if (viewerUserId == creatorUserId) return;

    // 1. Create bidirectional UserUser connection (no save yet â€” batched below)
    await _sharingService.EnsureConnectionAsync(creatorUserId, viewerUserId, saveChanges: false);

    // 2. Get the drop's tags
    var tagIds = await _context.NetworkDrops
        .Where(td => td.DropId == dropId)
        .Select(td => td.UserTagId)
        .ToListAsync();

    // 3. If drop has no tags (private), add it to creator's "All Connections" tag
    //    so the viewer can see it after PopulateEveryone adds them to that tag.
    if (!tagIds.Any())
    {
        var allConnectionsTag = await _context.UserNetworks
            .SingleAsync(t => t.UserId == creatorUserId && t.Name == "All Connections");

        bool alreadyTagged = await _context.NetworkDrops
            .AnyAsync(td => td.DropId == dropId && td.UserTagId == allConnectionsTag.UserTagId);

        if (!alreadyTagged)
        {
            _context.NetworkDrops.Add(new TagDrop
            {
                DropId = dropId,
                UserTagId = allConnectionsTag.UserTagId
            });
        }

        tagIds.Add(allConnectionsTag.UserTagId);
    }

    // 4. Batch-check existing TagViewer records to avoid N+1 queries
    var existingViewerTagIds = await _context.NetworkViewers
        .Where(nv => tagIds.Contains(nv.UserTagId) && nv.UserId == viewerUserId)
        .Select(nv => nv.UserTagId)
        .ToListAsync();

    foreach (var tagId in tagIds.Except(existingViewerTagIds))
    {
        _context.NetworkViewers.Add(new TagViewer
        {
            UserTagId = tagId,
            UserId = viewerUserId
        });
    }

    // 5. Single save for connection + TagViewer + TagDrop records
    await _context.SaveChangesAsync();

    // 6. Sync "All Connections" tag for both users
    await _groupService.PopulateEveryone(creatorUserId);
    await _groupService.PopulateEveryone(viewerUserId);
}
```

**Over-sharing note:** Adding the viewer as `TagViewer` on the drop's tags means they gain access to *all drops on those tags*, not just the shared drop. This is intentional â€” it matches the existing connection sharing model where accepting a share request grants access to an entire tag's worth of content. The share link acts as a lightweight connection invitation scoped to the creator's tags on that drop.

**Deactivation note:** If a share link is deactivated after a user has already claimed access, the user retains permanent access. The `TagViewer` and `UserUser` records persist independently of the link. This is intentional â€” you can't "un-share" something already seen. To revoke access, the creator would need to remove the viewer from their tags via the existing tag management UI.

#### New method on `ISharingService` / `SharingService`: `EnsureConnectionAsync`

```csharp
// Add to ISharingService interface:
Task EnsureConnectionAsync(int userIdA, int userIdB, bool saveChanges = true);
```

```csharp
/// <summary>
/// Creates bidirectional UserUser records if they don't already exist.
/// Idempotent â€” no-ops if connection already present.
/// </summary>
public async Task EnsureConnectionAsync(int userIdA, int userIdB, bool saveChanges = true)
{
    var existingAtoB = await Context.UserUsers
        .AnyAsync(uu => uu.OwnerUserId == userIdA && uu.ReaderUserId == userIdB);

    if (!existingAtoB)
    {
        var userB = await Context.UserProfiles.SingleAsync(u => u.UserId == userIdB);
        Context.UserUsers.Add(new UserUser
        {
            OwnerUserId = userIdA,
            ReaderUserId = userIdB,
            ReaderName = userB.Name,
            SendNotificationEmail = true
        });
    }

    var existingBtoA = await Context.UserUsers
        .AnyAsync(uu => uu.OwnerUserId == userIdB && uu.ReaderUserId == userIdA);

    if (!existingBtoA)
    {
        var userA = await Context.UserProfiles.SingleAsync(u => u.UserId == userIdA);
        Context.UserUsers.Add(new UserUser
        {
            OwnerUserId = userIdB,
            ReaderUserId = userIdA,
            ReaderName = userA.Name,
            SendNotificationEmail = true
        });
    }

    if (saveChanges)
    {
        await Context.SaveChangesAsync();
    }
}
```

#### Where `GrantDropAccessAsync` is called

| Scenario | Call site | Details |
|----------|-----------|---------|
| **Anonymous registers** | Inside `RegisterAndConnectAsync` | After user is created (or found), call `GrantDropAccessAsync(newUserId, shareLink)` |
| **Existing user signs in** | New endpoint: `POST /api/sharelinks/{token}/signin` | Delegates to existing `UserService` magic link method (`POST /api/users/token`) to send the email. The share token is not persisted server-side â€” the frontend stores it and redirects back to `/s/:token` after magic link verification, then calls `/claim`. |
| **Already authenticated** | `POST /api/sharelinks/{token}/claim` | Authenticated user claims permanent access. |

#### New endpoint for existing-user sign-in via share link

Add to `ShareLinkController`:

| Endpoint | Auth | Rate Limit | Description |
|----------|------|------------|-------------|
| `POST /api/sharelinks/{token}/signin` | None | 5 req/min per IP | Validates that the share link token is active, then delegates to existing `UserService` magic link flow (`POST /api/users/token`) to send email. Request body: `{ email }`. Returns `{ success: true }`. |
| `POST /api/sharelinks/{token}/claim` | Required | 10 req/min per user | Authenticated user claims permanent access to the drop. Calls `GrantDropAccessAsync`. Returns `{ success: true }`. |

**Why two endpoints instead of one for sign-in:** The magic link flow is async (user clicks email link), so we can't grant access during the initial sign-in request. Instead, after the user completes magic link auth and has a JWT, the frontend calls `/claim` to bind the drop access.

**For already-authenticated users:** The frontend detects a valid JWT when loading `/s/:token` and automatically calls `POST /api/sharelinks/{token}/claim` â€” no extra user action needed.

#### Updated interface

```csharp
public interface IMemoryShareLinkService
{
    Task<Guid> CreateLinkAsync(int userId, int dropId);
    Task<DropModel> GetMemoryByTokenAsync(Guid token);
    Task<string> RegisterAndConnectAsync(Guid token, string email, string name, bool acceptTerms);
    Task DeactivateLinkAsync(int userId, int dropId);
    Task ClaimDropAccessAsync(Guid token, int userId);  // NEW
}
```

#### Updated frontend flow (`SharedMemoryView`)

```
User arrives at /s/:token
  â”‚
  â”œâ”€ Has JWT? â”€â”€yesâ”€â”€â†’ GET /api/sharelinks/{token} (view memory)
  â”‚                     POST /api/sharelinks/{token}/claim (grant permanent access)
  â”‚                     Show memory + comment input
  â”‚
  â””â”€ No JWT? â”€â”€â”€â”€â”€â”€â”€â†’ GET /api/sharelinks/{token} (view memory read-only)
                       Show memory + registration/sign-in CTA
                         â”‚
                         â”œâ”€ Registers â†’ POST /api/sharelinks/{token}/register
                         â”‚              â†’ JWT returned, access granted, can comment
                         â”‚
                         â””â”€ Signs in  â†’ POST /api/sharelinks/{token}/signin (triggers magic link)
                                       â†’ User clicks magic link â†’ /auth/verify/:token
                                       â†’ Frontend redirects back to /s/:token
                                       â†’ POST /api/sharelinks/{token}/claim (grant access)
```

#### Additional tests

| Test | Type | Description |
|------|------|-------------|
| RegisterAndConnect_GrantsTagViewerAccess | Unit | After registration, user can see drop via `CanView` |
| ClaimAccess_AuthenticatedUser_GrantsAccess | Unit | Authenticated user calling `/claim` gets TagViewer records |
| ClaimAccess_AlreadyHasAccess_Idempotent | Unit | Calling `/claim` twice doesn't create duplicate TagViewers |
| ClaimAccess_CreatorViewsOwnLink_Noop | Unit | Creator claiming their own link is a no-op |
| GrantDropAccess_CreatesUserUserBidirectional | Unit | Both UserUser directions are created |
| GrantDropAccess_ExistingConnection_NoopConnection | Unit | Already-connected users don't get duplicate UserUser records |
| SignIn_ExistingUser_TriggersMagicLink | Unit | Sign-in via share link sends magic link email |
| GrantDropAccess_PrivateDrop_AddsToAllConnections | Unit | Private drop (no tags) gets added to "All Connections" tag and viewer gets TagViewer record |
| ClaimAccess_DeactivatedLink_Returns404 | Unit | Cannot claim access on a deactivated link |
| GrantDropAccess_ViewerSeesOtherDropsOnSameTags | Unit | Confirms viewer gains access to all drops on shared tags (intentional) |

---

## Cross-Cutting: CORS & Error States

### CORS

The .NET backend must allow requests from the Vue dev server (`localhost:5173`) and the production frontend domain. Add CORS policy in `Program.cs` / `Startup.cs`:
- Allow origin(s): frontend domain(s)
- Allow headers: `Authorization`, `Content-Type`
- Allow methods: `GET`, `POST`, `PUT`, `DELETE`

### Error & Empty States

Every view must handle these states. Reusable components:

| Component | Usage |
|-----------|-------|
| `EmptyState.vue` | Icon + message + optional CTA button |
| `ErrorState.vue` | Error message + retry button |
| `LoadingSpinner.vue` | Centered spinner |

**View-specific states:**

| View | Empty State | Error State |
|------|-------------|-------------|
| StreamView | "No memories yet. Capture your first moment." + CTA to `/memory/new` | "Couldn't load memories. Tap to retry." |
| MemoryDetailView | N/A | "This memory couldn't be found." (404) |
| SharedMemoryView | N/A | "This link is no longer active." (inactive/expired token) |
| CreateMemoryView | N/A | Upload failure: "Photo couldn't be uploaded. Try again." / "Video too large (max 500 MB)." |
| Comments section | "No comments yet. Be the first." | "Couldn't load comments." |

---

## Phase 2: Frontend â€” Project Setup & Auth

### 2.1 Project Structure

```
fyli-fe-v2/
â”œâ”€â”€ public/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/                  # Generic: buttons, dialogs, inputs
â”‚   â”‚   â”œâ”€â”€ memory/              # Memory card, creation form
â”‚   â”‚   â””â”€â”€ comment/             # Comment list, comment form
â”‚   â”œâ”€â”€ composables/
â”‚   â”‚   â”œâ”€â”€ useAuth.ts           # Auth state & magic link flow
â”‚   â”‚   â””â”€â”€ useApi.ts            # Axios wrapper with JWT
â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ authApi.ts           # /api/users endpoints
â”‚   â”‚   â”œâ”€â”€ memoryApi.ts         # /api/drops endpoints
â”‚   â”‚   â”œâ”€â”€ mediaApi.ts          # /api/images, /api/movies endpoints
â”‚   â”‚   â”œâ”€â”€ commentApi.ts        # /api/comments endpoints
â”‚   â”‚   â”œâ”€â”€ shareLinkApi.ts      # /api/sharelinks endpoints
â”‚   â”‚   â””â”€â”€ connectionApi.ts     # /api/connections endpoints
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â”œâ”€â”€ auth.ts              # User session, JWT
â”‚   â”‚   â””â”€â”€ stream.ts            # Memory feed state
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts             # TypeScript interfaces
â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterView.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginView.vue
â”‚   â”‚   â”‚   â””â”€â”€ MagicLinkView.vue
â”‚   â”‚   â”œâ”€â”€ stream/
â”‚   â”‚   â”‚   â””â”€â”€ StreamView.vue
â”‚   â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â”‚   â”œâ”€â”€ CreateMemoryView.vue
â”‚   â”‚   â”‚   â””â”€â”€ MemoryDetailView.vue
â”‚   â”‚   â”œâ”€â”€ share/
â”‚   â”‚   â”‚   â””â”€â”€ SharedMemoryView.vue    # Public: no auth required
â”‚   â”‚   â””â”€â”€ onboarding/
â”‚   â”‚       â”œâ”€â”€ WelcomeView.vue
â”‚   â”‚       â”œâ”€â”€ FirstMemoryView.vue
â”‚   â”‚       â””â”€â”€ FirstShareView.vue
â”‚   â”œâ”€â”€ App.vue
â”‚   â””â”€â”€ main.ts
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ vite.config.ts
```

### 2.2 Tech Stack

| Concern | Choice | Rationale |
|---------|--------|-----------|
| Framework | Vue 3 + Composition API | Per PRD decision |
| Language | TypeScript (strict) | Type safety |
| Build | Vite | Fast dev server, standard Vue tooling |
| State | Pinia | Official Vue state management |
| HTTP | Axios | Interceptors for JWT, familiar |
| Styling | Bootstrap 5 + scoped CSS | Mobile-first grid, consistent with existing work |
| Icons | Material Design Icons (@mdi/font) | Consistent with existing app |
| Router | Vue Router 4 | Standard |
| PWA | vite-plugin-pwa | Deferred â€” not in MVP scope. Add `manifest.json` placeholder only for future enablement |

### 2.3 Routes

| Path | View | Auth | Description |
|------|------|------|-------------|
| `/register` | RegisterView | No | Email + name signup |
| `/login` | LoginView | No | Request magic link |
| `/auth/verify/:token` | MagicLinkView | No | Validate magic link token, set JWT |
| `/` | StreamView | Yes | Memory feed (default) |
| `/memory/new` | CreateMemoryView | Yes | Create memory form |
| `/memory/:id` | MemoryDetailView | Yes | Full memory + comments |
| `/s/:token` | SharedMemoryView | No | Public shared memory view |
| `/onboarding/welcome` | WelcomeView | Yes | Step 1 of onboarding |
| `/onboarding/first-memory` | FirstMemoryView | Yes | Step 2 |
| `/onboarding/first-share` | FirstShareView | Yes | Step 3 |

### 2.4 Auth Flow

```
Register:
  RegisterView â†’ POST /api/users/register â†’ "Check your email" screen

Login:
  LoginView â†’ POST /api/users/token â†’ "Check your email" screen

Magic Link:
  User clicks email link â†’ /auth/verify/:token â†’ POST /api/users/login
  â†’ JWT stored in localStorage â†’ redirect to / (or onboarding if new user)

Share Link Registration:
  SharedMemoryView â†’ "Sign up to comment" CTA â†’ inline registration form
  â†’ POST /api/sharelinks/{token}/register â†’ JWT stored â†’ auto-connected
  â†’ redirect back to SharedMemoryView (now authenticated, can comment)
```

### 2.5 Auth Store (Pinia)

```typescript
// stores/auth.ts
interface AuthState {
  token: string | null;       // JWT
  user: User | null;
  isNewUser: boolean;         // Controls onboarding redirect
  shareToken: string | null;  // If user arrived via share link
}
```

**Key behavior:**
- On app init, check localStorage for JWT. If found, call `GET /api/users` to validate and load user.
- `isNewUser` set to `true` after registration. Cleared after onboarding completes.
- `shareToken` set when user arrives at `/s/:token`. If they register from there, redirect back to the shared memory after auth (not to onboarding).

---

## Phase 3: Frontend â€” Memory Stream & Creation

### 3.1 Stream Store (Pinia)

```typescript
// stores/stream.ts
interface StreamState {
  memories: Memory[];
  page: number;
  hasMore: boolean;
  loading: boolean;
}
```

**Actions:**
- `fetchPage()` â€” `GET /api/drops?page={page}` â†’ append to memories, increment page
- `reset()` â€” clear and reload from page 0

### 3.2 StreamView

- Renders list of `MemoryCard` components
- Infinite scroll: IntersectionObserver on sentinel element at bottom
- Floating "+" button â†’ navigates to `/memory/new`
- Pull-to-refresh on mobile

### 3.3 MemoryCard Component

Displays a single memory in the stream:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Avatar] Creator Name    Date   â”‚
â”‚                                 â”‚
â”‚ Description text...             â”‚
â”‚                                 â”‚
â”‚ [Photo grid / Video player]     â”‚
â”‚                                 â”‚
â”‚ ğŸ’¬ 3 comments     [Share]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Tap card â†’ navigate to `/memory/:id` (full detail + comments)
- Share button â†’ calls `POST /api/sharelinks/{dropId}` â†’ copies link to clipboard â†’ toast confirmation
- Photo grid: 1 photo = full width, 2 = side by side, 3+ = grid with "+N" overlay
- Video: inline player with poster thumbnail

### 3.4 CreateMemoryView

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† Back              [Save]     â”‚
â”‚                                 â”‚
â”‚ What happened?                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ (text area, autogrow)       â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                 â”‚
â”‚ ğŸ“… Today           [Change]    â”‚
â”‚                                 â”‚
â”‚ ğŸ“· Add photos  ğŸ¥ Add video    â”‚
â”‚                                 â”‚
â”‚ [Photo/video previews]          â”‚
â”‚                                 â”‚
â”‚ ğŸ”’ Private  /  ğŸ‘¥ Shared       â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Behavior:**
- Date defaults to today, date picker allows backdating
- Photo upload: `POST /api/images` per file, attach IDs to drop
- Video upload: `POST /api/movies/upload/request` â†’ direct S3 upload â†’ `POST /api/movies/upload/complete`
- Video limit: 500 MB (client-side validation before upload)
- Privacy toggle: binary private/shared
  - **Private:** `POST /api/drops` with empty `TagDrops` array â€” no groups attached, only creator can see it in the stream
  - **Shared:** Frontend calls `GET /api/groups` on app init to fetch user's groups, caches the list. When "Shared" is selected, all group IDs are attached as `TagDrops`. This mirrors the existing sharing model where visibility = union of all groups on the drop.
- Save: `POST /api/drops` with content, date, image IDs, movie IDs, tag IDs

### 3.5 MemoryDetailView

Full memory display + comment thread:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â† Back                [â‹® Menu]  â”‚
â”‚                                 â”‚
â”‚ [Full memory content]           â”‚
â”‚ [Full-size photos / video]      â”‚
â”‚                                 â”‚
â”‚ â”€â”€â”€ Comments â”€â”€â”€                â”‚
â”‚ [Comment 1]                     â”‚
â”‚ [Comment 2]                     â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” [Send]  â”‚
â”‚ â”‚ Add a comment...     â”‚  ğŸ“·   cd â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Menu (â‹®): Edit, Delete, Share link
- Edit â†’ inline editing of description, date, privacy, media
- Delete â†’ confirmation dialog â†’ `DELETE /api/drops/{id}`
- Comments loaded via `GET /api/comments/{dropId}`
- Add comment: `POST /api/comments` with optional photo

---

## Phase 4: Frontend â€” Shareable Links & Conversion

### 4.1 SharedMemoryView (`/s/:token`)

The viral growth page. No authentication required.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ğŸŒ¿ fyli                 â”‚
â”‚                                 â”‚
â”‚ [Creator Name] shared a moment  â”‚
â”‚                                 â”‚
â”‚ [Full memory content]           â”‚
â”‚ [Photos / Video]                â”‚
â”‚                                 â”‚
â”‚ â”€â”€â”€ Comments â”€â”€â”€                â”‚
â”‚ [Comment 1 - read only]         â”‚
â”‚ [Comment 2 - read only]         â”‚
â”‚                                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Sign up to comment and      â”‚ â”‚
â”‚ â”‚ share your own moments      â”‚ â”‚
â”‚ â”‚                             â”‚ â”‚
â”‚ â”‚ [Email]  [Name]             â”‚ â”‚
â”‚ â”‚ â˜‘ I agree to the Terms     â”‚ â”‚
â”‚ â”‚            [Join]           â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Flow:**
1. Load memory via `GET /api/sharelinks/{token}` (unauthenticated)
2. Render memory content, photos, video, comments (read-only)
3. CTA at bottom: inline registration form (email + name + terms checkbox)
4. On submit: `POST /api/sharelinks/{token}/register` with `{ email, name, acceptTerms: true }`
   - Backend delegates to UserService (registration) + SharingService (connection)
   - Returns JWT
5. Store JWT, set `shareToken` in auth store
6. Page reactively updates: comment input appears, user can now comment
7. No redirect to onboarding (per PRD: share-link users go back to the memory)

### 4.2 Share Flow (from authenticated user)

1. User taps "Share" on a MemoryCard or MemoryDetailView
2. Frontend calls `POST /api/sharelinks/{dropId}`
3. Backend returns `{ token }`, frontend constructs URL: `{baseUrl}/s/{token}`
4. URL copied to clipboard automatically
5. Toast: "Link copied! Share it with family."
6. User pastes into text message, WhatsApp, email, etc.

---

## Phase 5: Frontend â€” Onboarding

### 5.1 Onboarding Flow

**Only for users who register directly** (not via share link).

```
Register â†’ WelcomeView â†’ FirstMemoryView â†’ FirstShareView â†’ StreamView
```

### 5.2 WelcomeView

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                 â”‚
â”‚         Welcome to fyli         â”‚
â”‚                                 â”‚
â”‚   Capture the moments that      â”‚
â”‚   matter. Share them with the   â”‚
â”‚   people who matter.            â”‚
â”‚                                 â”‚
â”‚        [Get Started]            â”‚
â”‚                                 â”‚
â”‚         skip â†’                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.3 FirstMemoryView

Reuses `CreateMemoryView` component with additional helper text:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                 â”‚
â”‚   Capture your first moment     â”‚
â”‚   It can be anything â€” a photo  â”‚
â”‚   from today, a favorite memory,â”‚
â”‚   something your kid said.      â”‚
â”‚                                 â”‚
â”‚   [CreateMemoryView embedded]   â”‚
â”‚                                 â”‚
â”‚         skip â†’                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

After save â†’ auto-advance to FirstShareView.

### 5.4 FirstShareView

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                 â”‚
â”‚   Share it with someone         â”‚
â”‚                                 â”‚
â”‚   [Memory preview card]         â”‚
â”‚                                 â”‚
â”‚   [Copy share link]             â”‚
â”‚                                 â”‚
â”‚   or invite by email:           â”‚
â”‚   [email input] [Send]          â”‚
â”‚                                 â”‚
â”‚         skip â†’                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

After share (or skip) â†’ redirect to `/` (StreamView). Set `isNewUser = false`.

---

## Phase 6: Frontend â€” Email Invitations (Deprioritized)

Minimal implementation since share links are the primary mechanism.

### 6.1 Invite Connection

- Simple form accessible from stream header or settings
- Email input â†’ `POST /api/connections` with email and alias
- Confirmation toast

### 6.2 Accept Invitation

- Existing backend email flow sends link
- Link routes to `/register` or `/login` (if existing user)
- After auth, `POST /api/connections/confirm` establishes connection
- Redirect to stream

---

## API Mapping

Summary of all backend endpoints consumed by the new frontend:

| Frontend Action | Endpoint | Status |
|----------------|----------|--------|
| Register | `POST /api/users/register` | Existing |
| Request magic link | `POST /api/users/token` | Existing |
| Validate magic link | `POST /api/users/login` | Existing |
| Get current user | `GET /api/users` | Existing |
| Update name | `PUT /api/users` | Existing |
| Create memory | `POST /api/drops` | Existing |
| Get memory stream | `GET /api/drops` | Existing |
| Get single memory | `GET /api/drops/{id}` | Existing |
| Update memory | `PUT /api/drops/{id}` | Existing |
| Delete memory | `DELETE /api/drops/{id}` | Existing |
| Upload photo | `POST /api/images` | Existing |
| Get photo | `GET /api/images/{id}` | Existing |
| Request video upload URL | `POST /api/movies/upload/request` | Existing |
| Complete video upload | `POST /api/movies/upload/complete` | Existing |
| Get video | `GET /api/movies/{id}.mp4` | Existing |
| Get video thumbnail | `GET /api/movies/{id}/thumb` | Existing |
| Get comments | `GET /api/comments/{dropId}` | Existing |
| Add comment | `POST /api/comments` | Existing |
| Update comment | `PUT /api/comments/{id}` | Existing |
| Delete comment | `DELETE /api/comments/{id}` | Existing |
| Send invitation | `POST /api/connections` | Existing |
| Confirm connection | `POST /api/connections/confirm` | Existing |
| **Generate share link** | `POST /api/sharelinks/{dropId}` | **NEW** |
| **View shared memory** | `GET /api/sharelinks/{token}` | **NEW** |
| **Register via share link** | `POST /api/sharelinks/{token}/register` | **NEW** |
| **Deactivate share link** | `DELETE /api/sharelinks/{dropId}` | **NEW** |
| **Sign in via share link** | `POST /api/sharelinks/{token}/signin` | **NEW** |
| **Claim drop access** | `POST /api/sharelinks/{token}/claim` | **NEW** |

---

## Database Changes

**New table only:** `MemoryShareLinks` (see Phase 1.1)

**No changes to existing tables.** The new share link system is additive and does not modify existing `ShareRequests`, `Drops`, `UserUsers`, or any other table.

---

## Testing Plan

### Backend (Phase 1)

| Test | Type | Description |
|------|------|-------------|
| CreateLink_ValidDrop_ReturnsToken | Unit | Service creates link for owned drop |
| CreateLink_NotOwner_Throws | Unit | Cannot create link for someone else's drop |
| CreateLink_ExistingActive_ReturnsSame | Unit | Idempotent â€” returns existing token |
| GetMemoryByToken_Valid_ReturnsMemory | Unit | Returns drop + content + media + comments |
| GetMemoryByToken_Inactive_Returns404 | Unit | Deactivated links fail |
| GetMemoryByToken_IncrementsViewCount | Unit | View count goes up |
| RegisterAndConnect_NewUser_CreatesAccountAndConnection | Unit | Full registration + bidirectional connection |
| RegisterAndConnect_ExistingUser_ConnectsOnly | Unit | Existing email â†’ just connect |
| RegisterAndConnect_AlreadyConnected_NoopConnection | Unit | Users already connected â†’ skip connection, return JWT |
| RegisterAndConnect_MissingTerms_Throws | Unit | acceptTerms=false â†’ validation error |
| GetMemoryByToken_Expired_Returns404 | Unit | ExpiresAt in the past â†’ not found |
| CreateLink_PrivateDrop_Succeeds | Unit | Private memories can still be shared via link |
| ShareLinkController_Integration | Integration | Full endpoint tests |
| ShareLinkController_RateLimiting | Integration | Unauthenticated endpoints enforce rate limits |

### Frontend (Phases 2-6)

| Test | Type | Description |
|------|------|-------------|
| Auth store login/logout | Unit (Pinia) | JWT management, user state |
| Stream store pagination | Unit (Pinia) | Page loading, append behavior |
| MemoryCard renders correctly | Component | Content, photos, video, comment count |
| CreateMemoryView form validation | Component | Required fields, video size limit |
| SharedMemoryView unauthenticated | Component | Renders memory, shows registration CTA |
| SharedMemoryView post-registration | Component | Comment input appears after sign-up |
| Onboarding flow navigation | E2E | Register â†’ welcome â†’ first memory â†’ share â†’ stream |
| Share link copy | Component | Generates link, copies to clipboard |

---

## Implementation Order

| Phase | Scope | Dependencies |
|-------|-------|--------------|
| **Phase 1** | Backend: MemoryShareLinks table, service, controller | None |
| **Phase 2** | Frontend: project setup, auth flow, routing | None (auth uses existing endpoints only) |
| **Phase 3** | Frontend: memory stream, creation, detail + comments | Phase 2 |
| **Phase 4** | Frontend: shared memory public view, conversion flow | Phase 1 + Phase 2 |
| **Phase 5** | Frontend: onboarding (welcome â†’ first memory â†’ first share) | Phase 3 + Phase 4 |
| **Phase 6** | Frontend: email invitations (deprioritized) | Phase 2 |

Phases 1, 2, and 3 can begin in parallel. Phase 4 requires Phase 1. Phase 6 can be deferred or done last.

---

*Document Version: 1.2*
*Created: 2026-01-31*
*Updated: 2026-01-31 â€” v1.2: Added permanent drop access via share link (section 1.8), /claim and /signin endpoints, private drop handling, EnsureConnectionAsync, batched saves, over-sharing and deactivation behavior documented*
*Previous: v1.1 â€” Addressed code review (service delegation, rate limiting, terms acceptance, CORS, error states, privacy clarification, missing tests, dependency corrections)*
*Status: Draft*
